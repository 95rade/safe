#!/bin/bash
set -u

rc=0
platform=
arch=amd64

case $OSTYPE in
(darwin*)
	platform=darwin
	declare -a versions=(
		0.6.5
	)
	;;
(linux*)
	platform=linux
	declare -a versions=(
		0.5.0
		0.5.2
		0.6.4
		0.6.5
	)
	;;
(*)
	echo >&2 "UNRECOGNIZED OSTYPE '$OSTYPE'"
	exit 1
	;;
esac



bail() {
	echo >&2 $*
	exit 2
}
testing() {
	rm -f t/home/got t/home/want t/home/diff t/home/errors
	local v=$1 ; shift
	echo -n "[$v] $*... "
}
diffok() {
	if [[ -f t/home/errors && -s t/home/errors ]]; then
		echo "FAILED! (with errors:)"
		rc=1
		cat t/home/errors
		echo ; echo
	elif ! diff -u t/home/got t/home/want >t/home/diff 2>&1; then
		echo "FAILED!"
		rc=1
		cat t/home/diff
		echo ; echo
	else
		echo "ok"
	fi
}
yamlok() {
	[ -s t/home/got ] || echo "--- {}" > t/home/got
	spruce merge t/home/got  > t/home/got.x   ; mv t/home/got.x  t/home/got
	spruce merge t/home/want > t/home/want.x  ; mv t/home/want.x t/home/want
	diffok
}
exitok() {
	if [[ $1 -eq $2 ]]; then
		echo "ok"
	else
		echo "FAILED!"
		rc=1
		echo " expected process to exit $2"
		echo "   but it actually exited $1"
	fi
}

########################################################################

mkdir -p vaults t/tmp
trap 'rm -rf t/' INT QUIT TERM EXIT

for version in ${versions[@]}; do
	killall vault-${version} >/dev/null 2>&1 || true
done
for version in ${versions[@]}; do
	echo "VAULT ${version}"
	killall vault-${version} >/dev/null 2>&1 || true
	echo "----------------------------------------------"
	if [[ ! -f vaults/vault-${version} ]]; then
		echo "Downloading Vault ${version} CLI..."
		curl --fail -L > t/tmp/archive.zip \
			https://releases.hashicorp.com/vault/${version}/vault_${version}_${platform}_${arch}.zip \
			|| bail "download of vault ${version} failed"

		unzip -d t/tmp t/tmp/archive.zip
		mv t/tmp/vault vaults/vault-${version}
		echo "DONE"
		echo
	fi

	old_home=$HOME
	export HOME=${PWD}/t/home

	rm -rf t/home ; mkdir -p t/home
	#trap "rm -rf t/home" INT TERM QUIT EXIT

	./vaults/vault-${version} server -dev >t/home/log 2>&1 &
	vault_pid=$!
	waitfor=600
	while ! grep -iq '^root token: ' t/home/log; do
		if [[ $waitfor -gt 0 ]]; then
			waitfor=$((waitfor - 1))
			sleep 0.1
		else
			echo "FAILED - timed out waiting for vault server (-dev) to start"
			exit 3 # FIXME: this is the wrong thing to do
		fi
	done

	root_token=$(awk '/^Root Token:/ { print $3 }' < t/home/log | head -n1)
	unseal_key=$(awk '/^Unseal Key:/ { print $3 }' < t/home/log | head -n1)

	./safe target unit-tests http://127.0.0.1:8200
	./safe auth token <<<${root_token}

	testing $version basic set/get operation
	./safe set secret/handshake knock=knock >/dev/null
	./safe ask secret/handshake whos=there >/dev/null
	./safe get secret/handshake >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
--- # secret/handshake
knock: knock
whos: there
EOF
	yamlok

	testing $version basic check/exists operation
	./safe exists secret/handshake        ; exitok $? 0
	./safe exists secret/handshake:knock  ; exitok $? 0
	./safe exists secret/handshake:enoent ; exitok $? 1
	./safe exists secret/enoent           ; exitok $? 1
	./safe exists secret/enoent:sub       ; exitok $? 1

	testing $version multiple-attribute set operation
	./safe set secret/account username=admin password=sekrit >/dev/null
	./safe get secret/account >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
--- # secret/account
username: admin
password: sekrit
EOF
	yamlok

	testing $version password randomization
	./safe gen secret/random one     >/dev/null
	./safe gen secret/random another >/dev/null
	./safe get secret/random | spruce json >t/home/got 2>t/home/errors
	one=$(jq -r .one < t/home/got)
	another=$(jq -r .another < t/home/got)
	if [[ ${one} == ${another} ]]; then
		echo "FAILED"
		rc=1
		echo "  ... expected generated password '${one}'"
		echo "            to not be the same as '${another}'"
	else
		echo "ok"
	fi

	testing $version command chaining
	./safe gen secret/chained a -- gen secret/chained b -- gen secret/chained c >/dev/null
	./safe get secret/chained | spruce json > t/home/got 2>t/home/errors
	for k in a b c; do
		v=$(jq -r .$k < t/home/got)
		if [[ -z "$v" ]]; then
			echo "FAILED"
			rc=1
			echo "  ... expected secret/chained/$k to exist"
		else
			echo "ok"
		fi
	done


	testing $version custom password runes randomization

	./safe gen --policy "1-9" 64 secret/random one #    >/dev/null
	./safe get secret/random | spruce json >t/home/runed # 2>t/home/errors

	one=$(jq -r .one < t/home/runed)
	if [[ "$one" =~ ^[1-9]+$ ]]; then
		echo "ok"
	else
		echo "FAILED"
		rc=1
		echo "  expected generated password: '$one'"
		echo "              to only contain: [1-9]"
	fi

	testing $version password with secret:key syntax
	./safe gen 64 secret/random:two
	exitok $? 0
	./safe get secret/random:two
	exitok $? 0

	testing $version gen with multiple passwords to make
	./safe gen 64 secret/random:three secret/random four secret/random:five
	exitok $? 0
	./safe get secret/random:three; exitok $? 0
	./safe get secret/random:four; exitok $? 0
	./safe get secret/random:five; exitok $? 0

	testing $version gen with length flag
	./safe gen secret/random:six -l 10
	./safe get secret/random:six | tr -d '\n' >t/home/got
	if [[ $(cat t/home/got | wc -m) -ne 10 ]]; then
	  echo "FAILED"
		rc=1
		echo "Expected generated password to have 10 characters"
		echo "Got $(cat t/home/got | wc -m) instead"
  fi

	testing $version gen with incorrectly mixed path:key should fail
	./safe gen secret/random secret/random:seven 2>/dev/null; exitok $? 1

	testing $version gen with missing key should fail
	./safe gen secret/random 2>/dev/null; exitok $? 1

	testing $version single-value retrieval
	./safe set secret/single/value foo=bar baz=quux >/dev/null
	foo=$(./safe get secret/single/value:foo)
	if [[ ${foo} != "bar" ]]; then
		echo "FAILED"
		rc=1
		echo "  ... expected foo='bar'"
		echo "               got '${foo}'"
	else
		echo "ok"
	fi

	###### DELETE TESTS ######

	testing $version secret deletion
	./safe set secret/delete/one hello=world
	./safe delete secret/delete/one; exitok $? 0
	./safe get secret/delete/one; exitok $? 1

	testing $version multiple secret deletion
	./safe set secret/delete/two foo=bar
	./safe set secret/delete/three wom=bat
	./safe delete secret/delete/two secret/delete/three; exitok $? 0
	./safe get secret/delete/two; exitok $? 1
	./safe get secret/delete/three; exitok $? 1

	testing $version key deletion with key remaining within secret afterwards
	./safe set secret/delete/four foo=bar wom=bat
	./safe delete secret/delete/four:wom; exitok $? 0
	./safe get secret/delete/four:wom; exitok $? 1
	./safe get secret/delete/four:foo; exitok $? 0

	testing $version key deletion with no keys remaining should delete secret
	./safe set secret/delete/five foo=bar
	./safe delete secret/delete/five:foo; exitok $? 0
	./safe get secret/delete/five; exitok $? 1

	testing $version multiple key deletion
	./safe set secret/delete/six foo=bar wom=bat beep=boop
	./safe delete secret/delete/six:foo secret/delete/six:wom; exitok $? 0
	./safe get secret/delete/six:foo; exitok $? 1
	./safe get secret/delete/six:wom; exitok $? 1
	./safe get secret/delete/six:beep; exitok $? 0

	testing $version attempt to delete non-existent key should fail
	./safe delete secret/delete/gobbledegook; exitok $? 1

	testing $version attempt to delete non-existing key within existing secret should error
	./safe set secret/delete/seven foo=bar
	./safe delete secret/delete/seven:gobbledegook; exitok $? 1
	./safe get secret/delete/seven:foo; exitok $? 0

	testing $version delete non-existent key should not fail if -f is given
	./safe delete secret/delete/gobbledegook -f; exitok $? 0

	testing $version attempt to delete non-existing key within existing secret should error
	./safe set secret/delete/eight foo=bar
	./safe delete secret/delete/eight:gobbledegook -f; exitok $? 0
	./safe get secret/delete/seven:foo; exitok $? 0

	testing $version recursively delete a subtree
	./safe set secret/delete/subtree1/one foo=bar
	./safe set secret/delete/subtree1/two beep=boop
	./safe delete -Rf secret/delete/subtree1; exitok $? 0
	./safe get secret/delete/subtree1/one; exitok $? 1
	./safe get secret/delete/subtree1/two; exitok $? 1

	testing $version attempting to delete a subtree without -R should fail
	./safe set secret/delete/subtree2/one foo=bar
	./safe set secret/delete/subtree2/two foo=bar
	./safe delete -f secret/delete/subtree2; exitok $? 1
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/delete/subtree2/one:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/delete/subtree2/two:foo >t/home/got 2>t/home/errors; diffok

	testing $version recursively delete a leaf node secret
	./safe set secret/delete/nine foo=bar
	./safe delete -Rf secret/delete/nine; exitok $? 0
	./safe get secret/delete/nine; exitok $? 1

	testing $version recursively delete a key
	./safe set secret/delete/ten foo=bar beep=boop
	./safe delete -Rf secret/delete/ten:foo
	./safe get secret/delete/ten:foo; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/delete/ten:beep >t/home/got t/home/errors; diffok

	testing $version recursively delete a secret that does not exist with -f should not fail
	./safe delete -Rf secret/delete/gobbledegook; exitok $? 0

	testing $version recursively delete a key that does not exist with -f should not fail
	./safe set secret/delete/eleven beep=boop
	./safe delete -Rf secret/delete/eleven:foo; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/delete/eleven:beep >t/home/got 2>t/home/errors; diffok

	###### COPY TESTS ######

	testing $version copy a secret to another location
	./safe set secret/copy/from1 beep=boop
	./safe copy secret/copy/from1 secret/copy/to1; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from1:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to1:beep >t/home/got 2>t/home/errors; diffok


	testing $version copy a key to another secret without a key specified
	./safe set secret/copy/from2 beep=boop foo=bar
	./safe copy secret/copy/from2:beep secret/copy/to2; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from2:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to2:beep >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from2:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to2:foo; exitok $? 1


	testing $version copy a key to another specified key where the dest secret exists
	./safe set secret/copy/from3 beep=boop foo=bar
	./safe set secret/copy/to3 wom=bat
	./safe copy secret/copy/from3:beep secret/copy/to3:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from3:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:foo; exitok $? 1
cat >t/home/want <<EOF
bat
EOF
  ./safe get secret/copy/to3:wom >t/home/got 2>t/home/errors; diffok


	testing $version copy a key to another specified key where the dest secret does not exist
	./safe set secret/copy/from4 beep=boop foo=bar
	./safe copy secret/copy/from4:beep secret/copy/to4:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from3:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:foo; exitok $? 1


	testing $version copying a full secret to a specified key should fail
	./safe set secret/copy/from5 beep=boop
	./safe copy secret/copy/from5 secret/copy/to5:hello; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from5:beep >t/home/got 2>t/home/errors; diffok


	testing $version copying from a secret that does not exist should fail
	./safe copy secret/copy/from6 secret/copy/to6; exitok $? 1


	testing $version copying from a key where the underlying secret does not exist should fail
	./safe copy secret/copy/from7:beep secret/copy/to7; exitok $? 1


	testing $version copying from a missing key where the underlying secret exists should fail
	./safe set secret/copy/from8 foo=bar
	./safe copy secret/copy/from8:beep secret/copy/to8; exitok $? 1

	###### MOVE TESTS ######

	testing $version move a secret to another location
	./safe set secret/move/from1 beep=boop
	./safe move secret/move/from1 secret/move/to1; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from1:beep; exitok $? 1
	./safe get secret/move/to1:beep >t/home/got 2>t/home/errors; diffok


	testing $version move a key to another secret without a key specified
	./safe set secret/move/from2 beep=boop foo=bar
	./safe move secret/move/from2:beep secret/move/to2; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from2:beep; exitok $? 1
	./safe get secret/move/to2:beep >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from2:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to2:foo; exitok $? 1


	testing $version move a key to another specified key where the dest secret exists
	./safe set secret/move/from3 beep=boop foo=bar
	./safe set secret/move/to3 wom=bat
	./safe move secret/move/from3:beep secret/move/to3:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from3:beep; exitok $? 1
	./safe get secret/move/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to3:foo; exitok $? 1
cat >t/home/want <<EOF
bat
EOF
  ./safe get secret/move/to3:wom >t/home/got 2>t/home/errors; diffok


	testing $version move a key to another specified key where the dest secret does not exist
	./safe set secret/move/from4 beep=boop foo=bar
	./safe move secret/move/from4:beep secret/move/to4:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from3:beep; exitok $? 1
	./safe get secret/move/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to3:foo; exitok $? 1


	testing $version moving a full secret to a specified key should fail
	./safe set secret/move/from5 beep=boop
	./safe move secret/move/from5 secret/move/to5:beep; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from5:beep >t/home/got 2>t/home/errors; diffok


	testing $version moving from a secret that does not exist should fail
	./safe move secret/copy/from6 secret/move/to6; exitok $? 1


	testing $version moving from a key where the underlying secret does not exist should fail
	./safe move secret/move/from7:beep secret/move/to7; exitok $? 1


	testing $version moving from a missing key where the underlying secret exists should fail
	./safe set secret/move/from8 foo=bar
	./safe move secret/move/from8:beep secret/move/to8; exitok $? 1

  ###### TREE TESTS ######

	testing $version tree display
	./safe gen secret/tree/alpha     x >/dev/null
	./safe gen secret/tree/g         x >/dev/null
	./safe gen secret/tree/g/a       x >/dev/null
	./safe gen secret/tree/beta/name x >/dev/null
	./safe gen secret/tree/beta/env  x >/dev/null
	./safe gen secret/tree/g/a/m     x >/dev/null
	./safe gen secret/tree/g/a/m/m   x >/dev/null
	./safe gen secret/tree/g/a/m/m/a x >/dev/null
	./safe tree secret/tree >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
.
└── secret/tree
    ├── alpha
    ├── beta/
    │   ├── env
    │   └── name
    ├── g
    └── g/
        ├── a
        └── a/
            ├── m
            └── m/
                ├── m
                └── m/
                    └── a

EOF
	diffok
	./safe tree -d secret/tree >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
.
└── secret/tree
    ├── beta/
    └── g/
        └── a/
            └── m/
                └── m/

EOF
	diffok

	case ${version} in
	(0.5.0|0.5.2) ;;
	(*)
		testing ${version} tree not found errors
		./safe tree secret/enoent >t/home/got 2>&1
		cat >t/home/want <<EOF
!! no secret exists at path \`secret/enoent\`
EOF
		diffok
		;;
	esac

	testing ${version} tree export
	./safe set secret/export/admin username=admin password=sekrit         >/dev/null
	./safe set secret/export/robot username=bot password=beep-boop mark=2 >/dev/null
	./safe set secret/export/a/b/c subkey='the value given'               >/dev/null
	./safe export secret/export >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
---
secret/export/admin:
  username: admin
  password: sekrit
secret/export/robot:
  username: bot
  password: beep-boop
  mark: "2"
secret/export/a/b/c:
  subkey: the value given
EOF
	yamlok

	testing ${version} tree import
	cat <<EOF | spruce json >t/home/want
---
secret/import/admin:
  username: admin
  password: sekrit
secret/import/robot:
  username: bot
  password: beep-boop
  mark: "2"
secret/import/a/b/c:
  subkey: the value given
EOF
	./safe import secret/import <t/home/want >/dev/null
	./safe export secret/import >t/home/got 2>t/home/errors
	yamlok


	export HOME=${old_home}
	kill $vault_pid
	echo
	echo

	if grep -q 'goroutine' t/home/log; then
		exit 77 # ./try will pick up on this error code
	fi

	if [[ ${rc} -ne 0 ]]; then
		echo >&2 "---[ VAULT LOG ]------------------------------------------"
		cat  >&2 t/home/log
		echo >&2 "----------------------------------------------------------"
	fi
done

if [[ ${rc} -eq 0 ]]; then
	echo PASSED
else
	echo FAILED
fi
exit ${rc}
